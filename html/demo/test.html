<html>

<head>
    <title>Pattern marker example with Three.js and wasm</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            text-align: center;
            overflow-x: hidden;
        }

        .portrait canvas {
            transform-origin: 0 0;
            transform: rotate(-90deg) translateX(-100%);
        }

        /* .desktop canvas {
            transform: scale(-1, 1);
        } */
    </style>
</head>

<body>
    <script type='text/javascript'>
        var artoolkit_wasm_url = '../build/artoolkit_wasm.wasm';
    </script>
    <script src="/build/artoolkit_wasm.js"></script>
    <script src="/examples/js/third_party/three.js/three.min.js"></script>
    <script src="/js/artoolkit.three.js"></script>
    <script>
        function getUserMediaARController(configuration) {
            var obj = {};
            for (var i in configuration) {
                obj[i] = configuration[i];
            }
            var onSuccess = configuration.onSuccess;
            var cameraParamURL = configuration.cameraParam;
            var onError = configuration.onError || function (err) {
                console.error("ARController: Failed to load ARCameraParam", err);
            }

            obj.onSuccess = function () {
                new ARCameraParam(cameraParamURL, function () {
                    var arCameraParam = this;
                    var maxSize = configuration.maxARVideoSize || Math.max(video.videoWidth, video.videoHeight);
                    var f = maxSize / Math.max(video.videoWidth, video.videoHeight);
                    var w = f * video.videoWidth;
                    var h = f * video.videoHeight;
                    if (video.videoWidth < video.videoHeight) {
                        var tmp = w;
                        w = h;
                        h = tmp;
                    }
                    var arController = new ARController(w, h, arCameraParam);
                    arController.image = video;
                    if (video.videoWidth < video.videoHeight) {
                        arController.orientation = 'portrait';
                        arController.videoWidth = video.videoHeight;
                        arController.videoHeight = video.videoWidth;
                    } else {
                        arController.orientation = 'landscape';
                        arController.videoWidth = video.videoWidth;
                        arController.videoHeight = video.videoHeight;
                    }
                    onSuccess(arController, arCameraParam);
                }, function (err) {
                    ARController._teardownVideo(video);
                    onError(err);
                });
            };
            var video = ARController.getUserMedia(obj);
            return video;
        }

        function getUserMedia(configuration) {
            var facing = configuration.facingMode || 'environment';

            var onSuccess = configuration.onSuccess;
            var onError = configuration.onError || function (err) { console.error("ARController.getUserMedia", err); };

            var video = document.createElement('video');

            var readyToPlay = false;
            var eventNames = [
                'touchstart', 'touchend', 'touchmove', 'touchcancel',
                'click', 'mousedown', 'mouseup', 'mousemove',
                'keydown', 'keyup', 'keypress', 'scroll'
            ];
            var play = function () {
                if (readyToPlay) {
                    video.play().then(function () {
                        onSuccess(video);
                    }).catch(function (error) {
                        onError(error);
                        ARController._teardownVideo(video);
                    });
                    if (!video.paused) {
                        eventNames.forEach(function (eventName) {
                            window.removeEventListener(eventName, play, true);
                        });
                    }
                }
            };
            eventNames.forEach(function (eventName) {
                window.addEventListener(eventName, play, true);
            });

            var success = function (stream) {
                //DEPRECATED: don't use window.URL.createObjectURL(stream) any longer it might be removed soon. Only there to support old browsers src: https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
                if (window.URL.createObjectURL) {
                    //Need to add try-catch because iOS 11 fails to createObjectURL from stream. As this is deprecated  we should remove this soon
                    try {
                        video.srcObject = stream; // DEPRECATED: this feature is in the process to being deprecated
                    }
                    catch (ex) {
                        // Nothing todo, the purpose of this is to remove an error from the console on iOS 11
                    }
                }
                video.srcObject = stream; // This should be used instead. Which has the benefit to give us access to the stream object
                readyToPlay = true;
                video.autoplay = true;
                video.playsInline = true;
                play(); // Try playing without user input, should work on non-Android Chrome
            };

            var constraints = {};
            var mediaDevicesConstraints = {};
            if (configuration.width) {
                mediaDevicesConstraints.width = configuration.width;
                if (typeof configuration.width === 'object') {
                    if (configuration.width.max) {
                        constraints.maxWidth = configuration.width.max;
                    }
                    if (configuration.width.min) {
                        constraints.minWidth = configuration.width.min;
                    }
                } else {
                    constraints.maxWidth = configuration.width;
                }
            }

            if (configuration.height) {
                mediaDevicesConstraints.height = configuration.height;
                if (typeof configuration.height === 'object') {
                    if (configuration.height.max) {
                        constraints.maxHeight = configuration.height.max;
                    }
                    if (configuration.height.min) {
                        constraints.minHeight = configuration.height.min;
                    }
                } else {
                    constraints.maxHeight = configuration.height;
                }
            }

            mediaDevicesConstraints.facingMode = facing;
            mediaDevicesConstraints.deviceId = configuration.deviceId;

            // @ts-ignore: Ignored because it is needed to support older browsers
            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
            var hdConstraints = {
                audio: false,
                video: constraints
            };


            // @ts-ignore: ignored because it is needed to support older browsers
            if (navigator.mediaDevices || window.MediaStreamTrack.getSources) {
                if (navigator.mediaDevices) {
                    navigator.mediaDevices.getUserMedia({
                        audio: false,
                        video: mediaDevicesConstraints
                    }).then(success, onError);
                } else {
                    // This function of accessing the media device is deprecated and outdated and shouldn't be used anymore.
                    // @ts-ignore: ignored because it is needed to support older browsers
                    window.MediaStreamTrack.getSources(function (sources) {
                        var facingDir = mediaDevicesConstraints.facingMode;
                        if (facing && facing.exact) {
                            facingDir = facing.exact;
                        }
                        for (var i = 0; i < sources.length; i++) {
                            if (sources[i].kind === 'video' && sources[i].facing === facingDir) {
                                hdConstraints.video.mandatory.sourceId = sources[i].id;
                                break;
                            }
                        }
                        if (facing && facing.exact && !hdConstraints.video.mandatory.sourceId) {
                            onError('Failed to get camera facing the wanted direction');
                        } else {
                            if (navigator.getUserMedia) {
                                navigator.getUserMedia(hdConstraints, success, onError);
                            } else {
                                onError('navigator.getUserMedia is not supported on your browser');
                            }
                        }
                    });
                }
            } else {
                if (navigator.getUserMedia) {
                    navigator.getUserMedia(hdConstraints, success, onError);
                } else {
                    onError('navigator.getUserMedia is not supported on your browser');
                }
            }

            return video;
        }
    </script>

    <script>
        var configuration = {
            maxARVideoSize: 320, cameraParam: '/examples/Data/camera_para-iPhone 5 rear 640x480 1.0m.dat',
            onSuccess: function (arScene, arController, arCamera) {
                //arController.setPatternDetectionMode(artoolkit.AR_MATRIX_CODE_DETECTION);

                document.body.className = arController.orientation;

                var renderer = new THREE.WebGLRenderer({ antialias: true });
                if (arController.orientation === 'portrait') {
                    var w = (window.innerWidth / arController.videoHeight) * arController.videoWidth;
                    var h = window.innerWidth;
                    renderer.setSize(w, h);
                    renderer.domElement.style.paddingBottom = (w - h) + 'px';
                } else {
                    if (/Android|mobile|iPad|iPhone/i.test(navigator.userAgent)) {
                        renderer.setSize(window.innerWidth, (window.innerWidth / arController.videoWidth) * arController.videoHeight);
                    } else {
                        renderer.setSize(arController.videoWidth, arController.videoHeight);
                        document.body.className += ' desktop';
                    }
                }

                document.body.insertBefore(renderer.domElement, document.body.firstChild);

                var rotationV = 0;
                var rotationTarget = 0;

                renderer.domElement.addEventListener('click', function (ev) {
                    ev.preventDefault();
                    rotationTarget += 1;
                }, false);

                var sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 8, 8),
                    new THREE.MeshNormalMaterial()
                );
                sphere.material.flatShading;
                sphere.position.z = 40;
                sphere.position.x = 80;
                sphere.position.y = 80;
                sphere.scale.set(80, 80, 80);

                var torus = new THREE.Mesh(
                    new THREE.TorusGeometry(0.3, 0.2, 8, 8),
                    new THREE.MeshNormalMaterial()
                );
                torus.material.shading = THREE.FlatShading;
                torus.position.z = 0.5;
                torus.rotation.x = Math.PI / 2;

                // arController.loadNFTMarker('/examples/DataNFT/pinball', function (markerId) {
                //     var markerRoot = arController.createThreeNFTMarker(markerId);
                //     markerRoot.add(sphere);
                //     arScene.scene.add(markerRoot);
                // });

                arController.loadMarker('/examples/Data/patt.kanji', function (markerId) {
                    var markerRoot = arController.createThreeMarker(markerId);
                    markerRoot.add(torus);
                    arScene.scene.add(markerRoot);
                });

                var markerRoot = arController.createThreeBarcodeMarker(20);
                markerRoot.add(sphere);
                arScene.scene.add(markerRoot);

                var tick = function () {
                    arScene.process();

                    // rotationV += (rotationTarget - sphere.rotation.z) * 0.05;
                    // sphere.rotation.z += rotationV;
                    // torus.rotation.y += rotationV;
                    // rotationV *= 0.8;

                    arScene.renderOn(renderer);
                    requestAnimationFrame(tick);
                };

                tick();

            }
        };
        var obj = {};
        for (var i in configuration) {
            obj[i] = configuration[i];
        }
        var onSuccess = configuration.onSuccess;

        obj.onSuccess = function (arController, arCameraParam) {
            var scenes = arController.createThreeScene();
            onSuccess(scenes, arController, arCameraParam);
        };

        var configuration = obj;

        var video = this.getUserMediaARController(obj);
    </script>

</body>

</html>